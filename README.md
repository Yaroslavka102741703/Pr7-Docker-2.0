# Практическая работа: Дополнительные возможности Docker

---

## Цель работы

Изучение дополнительных возможностей Docker для управления жизненным циклом контейнеров, мониторинга их состояния и оптимизации использования системных ресурсов. Данная практика направлена на глубокое понимание операционных аспектов контейнеризации, что критически важно для построения надежных и масштабируемых приложений в production-среде.

---


## Задание 1: Вывод логов в файл

<img width="956" height="484" alt="image" src="https://github.com/user-attachments/assets/af4bbe7f-2fc2-4cc8-9571-49f784c406a6" />


## Задание 2: Проверка docker-stats

<img width="935" height="77" alt="image" src="https://github.com/user-attachments/assets/09ca8852-b0ec-4820-9d5d-d2f7436a8516" />

---



## Задание 3: Ограничение ресурсов

<img width="886" height="89" alt="image" src="https://github.com/user-attachments/assets/c99440ed-35c1-40b8-a6d8-531758ba6cb1" />

<img width="592" height="50" alt="image" src="https://github.com/user-attachments/assets/616ea94c-fa85-494a-9803-d8b048337421" />


<img width="877" height="54" alt="image" src="https://github.com/user-attachments/assets/fbc64165-1e01-4d1a-b8f1-5d042e0a85bb" />

---



## Задание 4: Экспорт в tar

<img width="631" height="399" alt="image" src="https://github.com/user-attachments/assets/82282ea5-368a-4ada-8cf0-f7eddb8b241a" />

<img width="1087" height="588" alt="image" src="https://github.com/user-attachments/assets/61740ee1-10aa-452d-9ea9-e6fc685134ed" />


---


## Задание 5: Импорт из tar

<img width="720" height="54" alt="image" src="https://github.com/user-attachments/assets/07565328-f0e7-478f-9020-0e4b439baa07" />


<img width="963" height="449" alt="image" src="https://github.com/user-attachments/assets/d5ba8540-8f81-4297-91f1-333dd8676007" />


<img width="1448" height="873" alt="image" src="https://github.com/user-attachments/assets/e3e8d799-f7dd-4f02-9c5a-376a039bc254" />


---


## Контрольные вопросы


### 1 Какие потоки данных перехватывает Docker при логировании и почему это важно для диагностики?

Docker по умолчанию перехватывает stdout и stderr процесса, запущенного в контейнере (PID 1). Эти потоки направляются в драйвер логирования, заданный в конфигурации Docker (обычно json-file или journald).

#### Почему это важно:

stdout/stderr — стандартный способ вывода логов в Unix-подобных системах. Приложения, написанные с учётом контейнеризации (12-factor apps), пишут логи именно туда.
Это позволяет централизованно собирать, фильтровать и анализировать логи (например, через docker logs <container>, Fluentd, ELK, Prometheus + Loki).
Если приложение пишет логи в файл внутри контейнера — они не будут видны через docker logs, и при удалении контейнера — потеряются (если не смонтирован volume).

---

### 2 Каким образом контрольные группы (cgroups) Linux обеспечивают ограничение ресурсов в Docker?

cgroups (control groups) — это механизм ядра Linux, позволяющий:

Ограничивать, учитывать и изолировать потребление ресурсов (CPU, память, I/O, сеть) для групп процессов.
Docker использует cgroups через runtime (например, runc) для:

Установки лимитов:
--memory=512m, --cpus=1.5, --pids-limit=100 и т.д.
Обеспечения изоляции: один контейнер не может "съесть" всю память или CPU хоста.
Мониторинга: статистика по использованию ресурсов берётся именно из cgroups.
Пример:
Когда вы запускаете docker run -m 256m ..., Docker создаёт cgroup с лимитом 256 МБ памяти. Если процесс превысит лимит — он получит OOM-Kill (Out-Of-Memory signal).

---


### 3 Сравнение `docker save` и `docker export` в Docker

В Docker есть два разных механизма для сохранения состояния: **сохранение образа (`docker save`)** и **экспорт контейнера (`docker export`)**. Они отличаются по содержимому, восстанавливаемости и применению.

#### Сравнение операций

| Характеристика | `docker save` (сохранение образа) | `docker export` (экспорт контейнера) |
| :--- | :--- | :--- |
| **Команда** | `docker save -o image.tar myimage:tag` | `docker export container_id -o container.tar` |
| **Что сохраняется** | Полный образ со всеми слоями и метаданными | Только файловая система контейнера на момент экспорта |
| **Сохраняются ли слои** | ? Да, вся история слоёв | ? Нет — создаётся плоский слой без истории |
| **Сохраняются ли метаданные** | ? `CMD`, `ENTRYPOINT`, `ENV`, `EXPOSE`, `VOLUME` и др. | ? Нет — метаданные теряются |
| **Способ восстановления** | `docker load -i image.tar` | `docker import container.tar [new-image:tag]` |
| **Подходит для резервного копирования** | ? Да — полная воспроизводимость | ?? Только для файловой системы, без конфигурации |

#### Типичные сценарии использования

##### Для `docker save` (сохранение образа):
- **Перенос образов между хостами** (через файл, когда нет доступа к реестру)
- **Артефакты в CI/CD** — сохранение собранного образа для последующих шагов
- **Резервное копирование образов** — полная копия со всей историей и конфигурацией
- **Долгосрочное хранение** конкретной версии образа

##### Для `docker export` (экспорт контейнера):
- **Экстренный дамп "живого" состояния** файловой системы запущенного контейнера
- **Восстановление данных** без исходного `Dockerfile` или репозитория
- **Анализ или аудит** текущего содержимого контейнера
- **Миграция или клонирование** состояния приложения, когда метаданные образа не важны

---

### 4 Почему важно устанавливать ограничения памяти для контейнеров в многоконтейнерной среде?
Без лимитов:

Один "прожорливый" контейнер может исчерпать всю RAM хоста > OOM-Kill других процессов (включая системные).
Возможна конкуренция за ресурсы, деградация производительности всех сервисов.
Сложно прогнозировать ёмкость хоста ("capacity planning").
С лимитами:

Гарантируется предсказуемость и изоляция.
Система может корректно планировать размещение контейнеров (особенно в Swarm/K8s).
Упрощается диагностика утечек памяти — контейнер падает с ошибкой, а не "ломает" всю систему.

---

### 5 Метрики docker stats и их интерпретация

| Метрика | Описание | Как интерпретировать для оптимизации |
| :--- | :--- | :--- |
| **CONTAINER ID / NAME** | Идентификатор или имя контейнера | Позволяет быстро локализовать проблемный сервис |
| **CPU %** | Процент использования CPU (суммарно по всем ядрам) | >80–90% постоянно > узкое место в CPU; рассмотреть оптимизацию кода или масштабирование |
| **MEM USAGE / LIMIT** | Текущее использование памяти / установленный лимит (если есть) | Приближение к лимиту > риск OOM-Kill; если лимит не задан — уязвимость для других контейнеров |
| **MEM %** | Процент от доступной памяти (хоста или лимита) | Высокий % > возможна утечка памяти или недостаточный лимит |
| **NET I/O** | Объём входящего/исходящего сетевого трафика (например, 1.2MB / 300KB) | Резкие скачки > аномальная активность, DDoS, неоптимальные запросы |
| **BLOCK I/O** | Объём операций чтения/записи на диск (например, 50MB / 10MB) | Высокая нагрузка > медленные диски, неоптимальная работа с файлами или БД |
| **PIDs** | Количество процессов внутри контейнера | Рост со временем > утечка процессов (например, fork без wait) |

#### Практические рекомендации

1. **Установите лимиты памяти (`-m`)** — без них `MEM %` отражает долю от всей памяти хоста, что вводит в заблуждение.
2. **Используйте `docker stats --no-stream`** для однократного снимка (удобно в скриптах).
3. **Комбинируйте с `docker top <container>`** для анализа конкретных процессов.
4. **Для долгосрочного мониторинга** подключите **cAdvisor + Prometheus + Grafana** — `docker stats` не сохраняет историю.

---


### 6 Как восстановить контейнер из tar-архива и какие ограничения существуют?
Если архив получен через docker export:

```bash
docker import cont.tar my-new-image:latest
docker run -it my-new-image
```

Ограничения:

Нет истории слоёв > нельзя docker diff или откатиться.
Потеряны метаданные: ENV, CMD, ENTRYPOINT, EXPOSE, VOLUMES.
Контейнер запускается с пустой точкой входа (/bin/sh по умолчанию) — нужно явно указывать команду.
Volumes и network settings не сохраняются.
Не подходит для восстановления "как было" — только файловая система.

---

### 7 Как использовать экспорт контейнеров для миграции приложений между хостами?

Хотя экспорт (docker export) можно использовать для миграции, это не рекомендуемый способ. Лучше:

#### Рекомендуемый путь:

Соберите образ через Dockerfile > docker build.
Сохраните: docker save -o app.tar image:tag.
Перенесите на другой хост > docker load -i app.tar.
Запустите > всё работает как задумано.

#### Если использовать docker export:

Придётся вручную восстанавливать CMD, ENV, порты.
Нет гарантии совместимости (особенно если ОС хостов разные).
Не масштабируемо.
